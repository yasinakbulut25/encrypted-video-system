"use client"

import { i as isUndefined, d as isNumber, u as useDisposalBin, e as effect, o as onDispose, l as listenEvent, D as DOMEvent, f as isNil, g as createScope, h as setAttribute, a as isString } from './vidstack-c3208662.js';
import { f as IS_SAFARI, g as isHLSSrc, h as getNumberOfDecimalPlaces, L as ListSymbol, j as isMediaStream } from './vidstack-3be5d39a.js';

class RAFLoop {
  constructor(_callback) {
    this.Bg = _callback;
  }
  uc() {
    if (!isUndefined(this.Dc))
      return;
    this.xj();
  }
  vc() {
    if (isNumber(this.Dc))
      window.cancelAnimationFrame(this.Dc);
    this.Dc = void 0;
  }
  xj() {
    this.Dc = window.requestAnimationFrame(() => {
      if (isUndefined(this.Dc))
        return;
      this.Bg();
      this.xj();
    });
  }
}

class HTMLMediaEvents {
  constructor(_provider, _ctx) {
    this.Wb = _provider;
    this.zi = _ctx;
    this.qi = useDisposalBin();
    this.Pi = false;
    this.Ri = false;
    this.Si = false;
    this.Qi = new RAFLoop(this.Vi.bind(this));
    this.Wi = void 0;
    this.pj = void 0;
    this.Xi();
    effect(this.Yi.bind(this));
    onDispose(this.si.bind(this));
  }
  get Ba() {
    return this.Wb.media;
  }
  get Wc() {
    return this.zi.delegate;
  }
  si() {
    this.Ri = false;
    this.Si = false;
    this.Qi.vc();
    this.qi.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  Vi() {
    const newTime = this.Wb.currentTime;
    if (this.zi.$state.currentTime() !== newTime)
      this.Oi(newTime);
  }
  Xi() {
    this.Ni("loadstart", this.Kf);
    this.Ni("abort", this.Ui);
    this.Ni("emptied", this.Zi);
    this.Ni("error", this.od);
  }
  _i() {
    if (this.Ri)
      return;
    this.qi.add(
      this.Ni("loadeddata", this.$i),
      this.Ni("loadedmetadata", this.aj),
      this.Ni("canplay", this.hd),
      this.Ni("canplaythrough", this.bj),
      this.Ni("durationchange", this.cj),
      this.Ni("play", this.qa),
      this.Ni("progress", this.dj),
      this.Ni("stalled", this.ej),
      this.Ni("suspend", this.fj)
    );
    this.Ri = true;
  }
  gj() {
    if (this.Si)
      return;
    this.qi.add(
      this.Ni("pause", this.ra),
      this.Ni("playing", this.hj),
      this.Ni("ratechange", this.ij),
      this.Ni("seeked", this.jj),
      this.Ni("seeking", this.kj),
      this.Ni("ended", this.lj),
      this.Ni("volumechange", this.vd),
      this.Ni("waiting", this.mj)
    );
    this.Si = true;
  }
  Ni(eventType, handler) {
    return listenEvent(
      this.Ba,
      eventType,
      handler.bind(this)
    );
  }
  qj(event2) {
    return;
  }
  Oi(time, trigger) {
    this.Wc.Nb("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this.zi.$state.seekableEnd()),
        played: this.Ba.played
      },
      trigger
    });
  }
  Kf(event2) {
    if (this.Ba.networkState === 3) {
      this.Ui(event2);
      return;
    }
    this._i();
    this.Wc.Nb("load-start", { trigger: event2 });
  }
  Ui(event2) {
    this.Wc.Nb("abort", { trigger: event2 });
  }
  Zi() {
    this.Wc.Nb("emptied", { trigger: event });
  }
  $i(event2) {
    this.Wc.Nb("loaded-data", { trigger: event2 });
  }
  aj(event2) {
    this.gj();
    this.Wc.Nb("volume-change", {
      detail: {
        volume: this.Ba.volume,
        muted: this.Ba.muted
      }
    });
    this.Wc.Nb("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this.zi.$state.source())) {
      this.Wc.Dg(this.Ti(), event2);
    }
  }
  Ti() {
    return {
      duration: this.Ba.duration,
      buffered: this.Ba.buffered,
      seekable: this.Ba.seekable
    };
  }
  qa(event2) {
    if (!this.zi.$state.canPlay)
      return;
    this.Wc.Nb("play", { trigger: event2 });
  }
  ra(event2) {
    if (this.Ba.readyState === 1 && !this.Pi)
      return;
    this.Pi = false;
    this.Qi.vc();
    this.Wc.Nb("pause", { trigger: event2 });
  }
  hd(event2) {
    this.Wc.Dg(this.Ti(), event2);
  }
  bj(event2) {
    if (this.zi.$state.started())
      return;
    this.Wc.Nb("can-play-through", {
      trigger: event2,
      detail: this.Ti()
    });
  }
  hj(event2) {
    this.Pi = false;
    this.Wc.Nb("playing", { trigger: event2 });
    this.Qi.uc();
  }
  ej(event2) {
    this.Wc.Nb("stalled", { trigger: event2 });
    if (this.Ba.readyState < 3) {
      this.Pi = true;
      this.Wc.Nb("waiting", { trigger: event2 });
    }
  }
  mj(event2) {
    if (this.Ba.readyState < 3) {
      this.Pi = true;
      this.Wc.Nb("waiting", { trigger: event2 });
    }
  }
  lj(event2) {
    this.Qi.vc();
    this.Oi(this.Ba.duration, event2);
    this.Wc.Nb("end", { trigger: event2 });
    if (this.zi.$state.loop()) {
      this.nj();
    } else {
      this.Wc.Nb("ended", { trigger: event2 });
    }
  }
  Yi() {
    if (this.zi.$state.paused()) {
      listenEvent(this.Ba, "timeupdate", this.oj.bind(this));
    }
  }
  oj(event2) {
    this.Oi(this.Ba.currentTime, event2);
  }
  cj(event2) {
    if (this.zi.$state.ended()) {
      this.Oi(this.Ba.duration, event2);
    }
    this.Wc.Nb("duration-change", {
      detail: this.Ba.duration,
      trigger: event2
    });
  }
  vd(event2) {
    this.Wc.Nb("volume-change", {
      detail: {
        volume: this.Ba.volume,
        muted: this.Ba.muted
      },
      trigger: event2
    });
  }
  jj(event2) {
    this.Oi(this.Ba.currentTime, event2);
    this.Wc.Nb("seeked", {
      detail: this.Ba.currentTime,
      trigger: event2
    });
    if (Math.trunc(this.Ba.currentTime) === Math.trunc(this.Ba.duration) && getNumberOfDecimalPlaces(this.Ba.duration) > getNumberOfDecimalPlaces(this.Ba.currentTime)) {
      this.Oi(this.Ba.duration, event2);
      if (!this.Ba.ended) {
        this.zi.player.dispatch(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  kj(event2) {
    this.Wc.Nb("seeking", {
      detail: this.Ba.currentTime,
      trigger: event2
    });
  }
  dj(event2) {
    this.Wc.Nb("progress", {
      detail: {
        buffered: this.Ba.buffered,
        seekable: this.Ba.seekable
      },
      trigger: event2
    });
  }
  nj() {
    const hasCustomControls = isNil(this.Ba.controls);
    if (hasCustomControls)
      this.Ba.controls = false;
    this.zi.player.dispatch(new DOMEvent("media-loop-request"));
  }
  fj(event2) {
    this.Wc.Nb("suspend", { trigger: event2 });
  }
  ij(event2) {
    this.Wc.Nb("rate-change", {
      detail: this.Ba.playbackRate,
      trigger: event2
    });
  }
  od(event2) {
    const error = this.Ba.error;
    if (!error)
      return;
    this.Wc.Nb("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
}

class NativeAudioTracks {
  constructor(_provider, _context) {
    this.Wb = _provider;
    this.R = _context;
    this.rj.onaddtrack = this.tj.bind(this);
    this.rj.onremovetrack = this.uj.bind(this);
    this.rj.onchange = this.vj.bind(this);
    listenEvent(this.R.audioTracks, "change", this.wj.bind(this));
  }
  get rj() {
    return this.Wb.media.audioTracks;
  }
  tj(event) {
    const _track = event.track;
    if (_track.label === "")
      return;
    const audioTrack = {
      id: _track.id + "",
      label: _track.label,
      language: _track.language,
      kind: _track.kind,
      selected: false
    };
    this.R.audioTracks[ListSymbol.h](audioTrack, event);
    if (_track.enabled)
      audioTrack.selected = true;
  }
  uj(event) {
    const track = this.R.audioTracks.getById(event.track.id);
    if (track)
      this.R.audioTracks[ListSymbol.f](track, event);
  }
  vj(event) {
    let enabledTrack = this.sj();
    if (!enabledTrack)
      return;
    const track = this.R.audioTracks.getById(enabledTrack.id);
    if (track)
      this.R.audioTracks[ListSymbol.$](track, true, event);
  }
  sj() {
    return Array.from(this.rj).find((track) => track.enabled);
  }
  wj(event) {
    const { current } = event.detail;
    if (!current)
      return;
    const track = this.rj.getTrackById(current.id);
    if (track) {
      const prev = this.sj();
      if (prev)
        prev.enabled = false;
      track.enabled = true;
    }
  }
}

class HTMLMediaProvider {
  constructor(_media) {
    this.Ba = _media;
    this.scope = createScope();
    this.jg = null;
  }
  setup(context) {
    new HTMLMediaEvents(this, context);
    if ("audioTracks" in this.media)
      new NativeAudioTracks(this, context);
    onDispose(() => {
      this.Ba.setAttribute("src", "");
      this.Ba.load();
    });
  }
  get type() {
    return "";
  }
  get media() {
    return this.Ba;
  }
  get currentSrc() {
    return this.jg;
  }
  get paused() {
    return this.Ba.paused;
  }
  get muted() {
    return this.Ba.muted;
  }
  set muted(muted) {
    this.Ba.muted = muted;
  }
  get volume() {
    return this.Ba.volume;
  }
  set volume(volume) {
    this.Ba.volume = volume;
  }
  get currentTime() {
    return this.Ba.currentTime;
  }
  set currentTime(time) {
    this.Ba.currentTime = time;
  }
  get playsinline() {
    return this.Ba.hasAttribute("playsinline");
  }
  set playsinline(playsinline) {
    setAttribute(this.Ba, "playsinline", playsinline);
  }
  get playbackRate() {
    return this.Ba.playbackRate;
  }
  set playbackRate(rate) {
    this.Ba.playbackRate = rate;
  }
  async play() {
    return this.Ba.play();
  }
  async pause() {
    return this.Ba.pause();
  }
  async loadSource({ src, type }, preload) {
    this.Ba.preload = preload || "";
    if (isMediaStream(src)) {
      this.Ba.srcObject = src;
    } else {
      this.Ba.srcObject = null;
      this.Ba.src = isString(src) ? src : window.URL.createObjectURL(src);
    }
    this.Ba.load();
    this.jg = { src, type };
  }
}

export { HTMLMediaProvider as H, RAFLoop as R };
