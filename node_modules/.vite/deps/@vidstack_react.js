"use client";
import {
  Icon
} from "./chunk-AOSIHWY7.js";
import {
  ARIAKeyShortcuts,
  AudioProviderLoader,
  AudioRadioGroup,
  AudioTrackList,
  CaptionButton,
  CaptionButtonInstance,
  Captions,
  CaptionsInstance,
  CaptionsRadioGroup,
  ChapterTitle,
  ChaptersRadioGroup,
  ControlsGroup,
  ControlsGroupInstance,
  ControlsInstance,
  DOMEvent,
  DefaultAudioLayout,
  DefaultLayout,
  DefaultVideoLayout,
  FullscreenButton,
  FullscreenButtonInstance,
  FullscreenController,
  Gesture,
  GestureInstance,
  HLSProviderLoader,
  IS_SERVER$1,
  List,
  LiveButton,
  LiveButtonInstance,
  Logger,
  MEDIA_KEY_SHORTCUTS,
  MediaControls,
  MediaPlayerInstance,
  MediaProviderInstance,
  MediaRemoteControl,
  MenuButton,
  MenuButtonInstance,
  MenuInstance,
  MenuItem,
  MenuItemInstance,
  MenuItems,
  MenuItemsInstance,
  MenuPortal,
  MenuPortalInstance,
  MuteButton,
  MuteButtonInstance,
  PIPButton,
  PIPButtonInstance,
  PlayButton,
  PlayButtonInstance,
  PlayerQueryList,
  PosterInstance,
  Primitive,
  QualityRadioGroup,
  Radio,
  RadioGroupInstance,
  RadioInstance,
  ScreenOrientationController,
  SeekButton,
  SeekButtonInstance,
  SliderChapters,
  SliderChaptersInstance,
  SliderController,
  SliderInstance,
  SliderPreview,
  SliderPreviewInstance,
  SliderThumbnail,
  SliderThumbnailInstance,
  SliderValue,
  SliderValueInstance,
  SliderVideo,
  SliderVideoInstance,
  SpeedRadioGroup,
  TextRenderers,
  TextTrack,
  TextTrackList,
  TextTrackSymbol,
  ThumbnailInstance,
  ThumbnailsLoader,
  Time,
  TimeInstance,
  TimeRange,
  TimeSliderInstance,
  ToggleButtonInstance,
  TooltipContent,
  TooltipContentInstance,
  TooltipInstance,
  TooltipTrigger,
  TooltipTriggerInstance,
  VideoProviderLoader,
  VideoQualityList,
  VolumeSliderInstance,
  appendTriggerEvent,
  canChangeVolume,
  canFullscreen,
  canOrientScreen,
  canPlayHLSNatively,
  canRotateScreen,
  canUsePictureInPicture,
  canUseVideoPresentation,
  composeRefs,
  controls,
  createReactComponent,
  defaultLayoutContext,
  effect,
  findActiveCue,
  findTriggerEvent,
  formatSpokenTime,
  formatTime,
  getDefaultLayoutLang,
  getTimeRangesEnd,
  getTimeRangesStart,
  hasTriggerEvent,
  isAudioProvider,
  isCueActive,
  isHLSProvider,
  isHTMLAudioElement,
  isHTMLMediaElement,
  isHTMLVideoElement,
  isKeyboardClick,
  isKeyboardEvent,
  isPointerEvent,
  isString,
  isTrackCaptionKind,
  isVideoProvider,
  listenEvent,
  mediaContext,
  mediaState,
  menu,
  menuPortalContext,
  observeActiveTextTrack,
  parseJSONCaptionsFile,
  radioGroup,
  scoped,
  signal,
  slider,
  sliderContext,
  sliderState,
  softResetMediaState,
  thumbnail,
  timeSlider,
  tooltip,
  updateSliderPreviewPlacement,
  useActiveTextCues,
  useActiveTextTrack,
  useAudioOptions,
  useCaptionOptions,
  useChapterOptions,
  useDefaultLayoutContext,
  useMediaState,
  useMediaStore,
  usePlaybackRateOptions,
  usePlayerQuery,
  useReactContext,
  useReactScope,
  useSignal,
  useSignalRecord,
  useStateContext,
  useVideoQualityOptions,
  volumeSlider,
  walkTriggerEventChain
} from "./chunk-NPLKRREU.js";
import {
  require_react_dom
} from "./chunk-GVSLPJMJ.js";
import {
  require_react
} from "./chunk-ZLZLTJQL.js";
import {
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/@vidstack/react/dist/dev/vidstack.js
var React = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var LibASSTextRenderer = class {
  constructor(loader, config) {
    this.loader = loader;
    this.config = config;
    this.priority = 1;
    this._instance = null;
    this._track = null;
    this._typeRE = /(ssa|ass)$/;
  }
  canRender(track) {
    return !!track.src && (isString(track.type) && this._typeRE.test(track.type) || this._typeRE.test(track.src));
  }
  attach(video) {
    this.loader().then(async (mod) => {
      var _a;
      this._instance = new mod.default({
        ...this.config,
        video,
        subUrl: ((_a = this._track) == null ? void 0 : _a.src) || ""
      });
      listenEvent(this._instance, "ready", () => {
        var _a2;
        const canvas = (_a2 = this._instance) == null ? void 0 : _a2._canvas;
        if (canvas)
          canvas.style.pointerEvents = "none";
      });
      listenEvent(this._instance, "error", (event) => {
        if (this._track) {
          this._track[TextTrackSymbol._readyState] = 3;
          this._track.dispatchEvent(
            new DOMEvent("error", {
              trigger: event,
              detail: event.error
            })
          );
        }
      });
    });
  }
  changeTrack(track) {
    var _a;
    if (!track || track.readyState === 3) {
      this._freeTrack();
    } else if (this._track !== track) {
      (_a = this._instance) == null ? void 0 : _a.setTrackByUrl(track.src);
      this._track = track;
    }
  }
  detach() {
    this._freeTrack();
  }
  _freeTrack() {
    var _a;
    (_a = this._instance) == null ? void 0 : _a.freeTrack();
    this._track = null;
  }
};
var MediaPlayerBridge = createReactComponent(MediaPlayerInstance, {
  events: [
    "onAbort",
    "onControlsChange",
    "onDurationChange",
    "onEmptied",
    "onError",
    "onFindMediaPlayer",
    "onOrientationChange",
    "onPause",
    "onPlaysinlineChange",
    "onPosterChange",
    "onProgress",
    "onReplay",
    "onStarted",
    "onSuspend",
    "onStalled",
    "onWaiting"
  ],
  eventsRegex: /^on(Can|Auto|Source|User|Fullscreen|End|Load|Play|Provider|Picture|Hls|Media|Live|Loop|Audio|Video|Time|TextTrack|Volume|Quality?|Rate|Seek|Stream|Destroy|Vds)/
});
var MediaPlayer = React.forwardRef(
  ({ aspectRatio, children, ...props }, forwardRef2) => {
    return React.createElement(
      MediaPlayerBridge,
      {
        ...props,
        ref: forwardRef2,
        style: {
          aspectRatio,
          ...props.style
        }
      },
      (props2) => React.createElement(Primitive.div, { ...props2 }, children)
    );
  }
);
MediaPlayer.displayName = "MediaPlayer";
var MediaProviderBridge = createReactComponent(MediaProviderInstance);
var MediaProvider = React.forwardRef(
  ({ children, mediaProps, ...props }, forwardRef2) => {
    return React.createElement(MediaProviderBridge, { ...props, ref: forwardRef2 }, (props2, instance) => React.createElement("div", { ...props2 }, React.createElement(MediaOutlet, { ...mediaProps, provider: instance }), children));
  }
);
MediaProvider.displayName = "MediaProvider";
function MediaOutlet({ provider, ...props }) {
  const { controls: controls2, crossorigin, poster } = useStateContext(mediaState), { loader } = provider.$state, { $iosControls: iosControls } = useReactContext(mediaContext), $controls = useSignal(controls2), $iosControls = useSignal(iosControls), $crossorigin = useSignal(crossorigin), $poster = useSignal(poster), $loader = useSignal(loader), $mediaType = $loader == null ? void 0 : $loader.mediaType();
  return $mediaType ? React.createElement($mediaType === "audio" ? "audio" : "video", {
    ...props,
    controls: $controls || $iosControls ? "" : null,
    crossOrigin: typeof $crossorigin === "boolean" ? "" : $crossorigin,
    poster: $mediaType === "video" && ($controls || $iosControls) && $poster ? $poster : null,
    preload: "none",
    "aria-hidden": "true",
    suppressHydrationWarning: true,
    ref(el) {
      provider.load(el);
    }
  }) : null;
}
MediaOutlet.displayName = "MediaOutlet";
function createTextTrack(init) {
  const media = useReactContext(mediaContext), track = React.useMemo(() => new TextTrack(init), Object.values(init));
  React.useEffect(() => {
    media.textTracks.add(track);
    return () => void media.textTracks.remove(track);
  }, [track]);
  return track;
}
function Track({ lang, ...props }) {
  createTextTrack({ language: lang, ...props });
  return null;
}
Track.displayName = "Track";
var ToggleButtonBridge = createReactComponent(ToggleButtonInstance);
var ToggleButton = React.forwardRef(
  ({ children, ...props }, forwardRef2) => {
    return React.createElement(ToggleButtonBridge, { ...props }, (props2) => React.createElement(Primitive.button, { ...props2, ref: composeRefs(props2.ref, forwardRef2) }, children));
  }
);
ToggleButton.displayName = "ToggleButton";
var Root = React.forwardRef(({ children, ...props }, forwardRef2) => {
  return React.createElement(
    Primitive.div,
    {
      translate: "yes",
      "aria-live": "off",
      "aria-atomic": "true",
      ...props,
      ref: forwardRef2
    },
    children
  );
});
Root.displayName = "Caption";
var Text = React.forwardRef((props, forwardRef2) => {
  const textTrack = useMediaState("textTrack"), [activeCue, setActiveCue] = React.useState();
  React.useEffect(() => {
    if (!textTrack)
      return;
    function onCueChange() {
      setActiveCue(textTrack == null ? void 0 : textTrack.activeCues[0]);
    }
    textTrack.addEventListener("cue-change", onCueChange);
    return () => {
      textTrack.removeEventListener("cue-change", onCueChange);
      setActiveCue(void 0);
    };
  }, [textTrack]);
  return React.createElement(
    Primitive.span,
    {
      ...props,
      "data-part": "cue",
      dangerouslySetInnerHTML: {
        __html: (activeCue == null ? void 0 : activeCue.text) || ""
      },
      ref: forwardRef2
    }
  );
});
Text.displayName = "CaptionText";
var caption = Object.freeze({
  __proto__: null,
  Root,
  Text
});
var PosterBridge = createReactComponent(PosterInstance);
var Poster = React.forwardRef(
  ({ children, ...props }, forwardRef2) => {
    return React.createElement(PosterBridge, { ...props }, (props2, instance) => React.createElement(PosterImg, { ...props2, instance, ref: composeRefs(props2.ref, forwardRef2) }, children));
  }
);
Poster.displayName = "Poster";
var PosterImg = React.forwardRef(
  ({ instance, children, ...props }, forwardRef2) => {
    const { crossorigin } = useStateContext(mediaState), { src, alt, img } = instance.$state, $crossorigin = useSignal(crossorigin), $src = useSignal(src), $alt = useSignal(alt);
    return React.createElement(
      Primitive.img,
      {
        ...props,
        src: $src || void 0,
        alt: $alt || void 0,
        crossOrigin: $crossorigin,
        ref: composeRefs(img.set, forwardRef2)
      },
      children
    );
  }
);
PosterImg.displayName = "PosterImg";
function useState2(ctor, prop, ref) {
  const initialValue = React.useMemo(() => ctor.state.record[prop], [ctor, prop]);
  return useSignal(ref.current ? ref.current.$state[prop] : initialValue);
}
var storesCache = /* @__PURE__ */ new Map();
function useStore(ctor, ref) {
  const initialStore = React.useMemo(() => {
    let store = storesCache.get(ctor);
    if (!store) {
      store = new Proxy(ctor.state.record, {
        get: (_, prop) => () => ctor.state.record[prop]
      });
      storesCache.set(ctor, store);
    }
    return store;
  }, [ctor]);
  return useSignalRecord(ref.current ? ref.current.$state : initialStore);
}
function useMediaPlayer() {
  const context = useReactContext(mediaContext);
  if (!context) {
    throw Error(
      "[vidstack] no media context was found - was this called outside of `<MediaPlayer>`?"
    );
  }
  return (context == null ? void 0 : context.player) || null;
}
function useMediaProvider() {
  const [provider, setProvider] = React.useState(null), context = useReactContext(mediaContext);
  if (!context) {
    throw Error(
      "[vidstack] no media context was found - was this called outside of `<MediaPlayer>`?"
    );
  }
  React.useEffect(() => {
    if (!context)
      return;
    return effect(() => {
      setProvider(context.$provider());
    });
  }, []);
  return provider;
}
function useMediaRemote(target) {
  const media = useReactContext(mediaContext), remote = React.useRef();
  if (!remote.current) {
    remote.current = new MediaRemoteControl();
  }
  React.useEffect(() => {
    const ref = target && "current" in target ? target.current : target, isPlayerRef = ref instanceof MediaPlayerInstance, player = isPlayerRef ? ref : media == null ? void 0 : media.player;
    remote.current.setPlayer(player ?? null);
    remote.current.setTarget(ref ?? null);
  }, [media, target && "current" in target ? target.current : target]);
  return remote.current;
}
function useThumbnails(src) {
  const scope = useReactScope(), $src = React.useMemo(() => signal(src), []), loader = React.useMemo(() => scoped(() => ThumbnailsLoader.create($src), scope), []), $cues = useSignal(loader.$cues), data = React.useMemo(() => {
    const items = [], baseURL = /^https?:/.test(src) || IS_SERVER$1 ? src : location.href;
    for (const cue of $cues) {
      const [url, dataText = ""] = (cue.text || "").split("#"), data2 = resolveThumbnailData(dataText);
      items.push({
        url: resolveThumbnailSrc(url, baseURL),
        cue,
        x: data2.x ?? -1,
        y: data2.y ?? -1,
        width: data2.width ?? -1,
        height: data2.height ?? -1
      });
    }
    return items;
  }, [$cues]);
  if (!scope) {
    console.warn(
      `[vidstack] \`useThumbnails\` must be called inside a child component of \`<MediaPlayer>\``
    );
  }
  React.useEffect(() => {
    $src.set(src);
  }, [src]);
  return data;
}
function useActiveThumbnail(thumbnails, time) {
  const cues = React.useMemo(() => thumbnails.map((t) => t.cue), [thumbnails]);
  return React.useMemo(() => {
    const cue = findActiveCue(cues, time);
    return thumbnails.find((t) => t.cue === cue) || null;
  }, [thumbnails, cues, time]);
}
function resolveThumbnailSrc(src, baseURL) {
  return /^https?:/.test(src) ? src : new URL(src, baseURL).href;
}
var propNames = {
  x: "x",
  y: "y",
  w: "width",
  h: "height"
};
function resolveThumbnailData(data) {
  const [props, values] = data.split("="), resolvedData = {}, dataValues = values == null ? void 0 : values.split(",");
  if (!props || !values)
    return {};
  for (let i = 0; i < props.length; i++) {
    resolvedData[propNames[props[i]]] = +dataValues[i];
  }
  return resolvedData;
}
function useSliderState(prop, ref) {
  var _a;
  const $state = useStateContext(sliderState);
  if (!$state && !ref) {
    console.warn(
      `[vidstack] \`useSliderState\` requires \`RefObject<SliderInstance>\` argument if called outside of a slider component`
    );
  }
  return useSignal((((_a = ref == null ? void 0 : ref.current) == null ? void 0 : _a.$state) || $state)[prop]);
}
function useSliderStore(ref) {
  var _a;
  const $state = useStateContext(sliderState);
  if (!$state && !ref) {
    console.warn(
      `[vidstack] \`useSliderStore\` requires \`RefObject<SliderInstance>\` argument if called outside of a slider component`
    );
  }
  return useSignalRecord(((_a = ref == null ? void 0 : ref.current) == null ? void 0 : _a.$state) || $state);
}
function useSliderPreview({
  clamp = false,
  offset = 0,
  orientation = "horizontal"
} = {}) {
  const [rootRef, setRootRef] = React.useState(null), [previewRef, setPreviewRef] = React.useState(null), [pointerValue, setPointerValue] = React.useState(0), [isVisible, setIsVisible] = React.useState(false);
  React.useEffect(() => {
    if (!rootRef)
      return;
    const dragging = signal(false);
    function updatePointerValue(event) {
      if (!rootRef)
        return;
      setPointerValue(getPointerValue(rootRef, event, orientation));
    }
    return effect(() => {
      if (!dragging()) {
        listenEvent(rootRef, "pointerenter", () => {
          setIsVisible(true);
          previewRef == null ? void 0 : previewRef.setAttribute("data-visible", "");
        });
        listenEvent(rootRef, "pointerdown", (event) => {
          dragging.set(true);
          updatePointerValue(event);
        });
        listenEvent(rootRef, "pointerleave", () => {
          setIsVisible(false);
          previewRef == null ? void 0 : previewRef.removeAttribute("data-visible");
        });
        listenEvent(rootRef, "pointermove", (event) => {
          updatePointerValue(event);
        });
        return;
      }
      previewRef == null ? void 0 : previewRef.setAttribute("data-dragging", "");
      listenEvent(document, "pointerup", (event) => {
        dragging.set(false);
        previewRef == null ? void 0 : previewRef.removeAttribute("data-dragging");
        updatePointerValue(event);
      });
      listenEvent(document, "pointermove", (event) => {
        updatePointerValue(event);
      });
      listenEvent(document, "touchmove", (e) => e.preventDefault(), {
        passive: false
      });
    });
  }, [rootRef]);
  React.useEffect(() => {
    if (previewRef) {
      previewRef.style.setProperty("--slider-pointer", pointerValue + "%");
    }
  }, [previewRef, pointerValue]);
  React.useEffect(() => {
    if (!previewRef)
      return;
    const update = () => {
      updateSliderPreviewPlacement(previewRef, {
        offset,
        clamp,
        orientation
      });
    };
    update();
    const resize = new ResizeObserver(update);
    resize.observe(previewRef);
    return () => resize.disconnect();
  }, [previewRef, clamp, offset, orientation]);
  return {
    previewRootRef: setRootRef,
    previewRef: setPreviewRef,
    previewValue: pointerValue,
    isPreviewVisible: isVisible
  };
}
function getPointerValue(root, event, orientation) {
  let thumbPositionRate, rect = root.getBoundingClientRect();
  if (orientation === "vertical") {
    const { bottom: trackBottom, height: trackHeight } = rect;
    thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
  } else {
    const { left: trackLeft, width: trackWidth } = rect;
    thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
  }
  return round(Math.max(0, Math.min(100, 100 * thumbPositionRate)));
}
function round(num) {
  return Number(num.toFixed(3));
}
export {
  ARIAKeyShortcuts,
  AudioProviderLoader,
  AudioRadioGroup,
  AudioTrackList,
  caption as Caption,
  CaptionButton,
  CaptionButtonInstance,
  Captions,
  CaptionsInstance,
  CaptionsRadioGroup,
  ChapterTitle,
  ChaptersRadioGroup,
  controls as Controls,
  ControlsGroup,
  ControlsGroupInstance,
  ControlsInstance,
  DefaultAudioLayout,
  DefaultLayout,
  DefaultVideoLayout,
  FullscreenButton,
  FullscreenButtonInstance,
  FullscreenController,
  Gesture,
  GestureInstance,
  HLSProviderLoader,
  Icon,
  LibASSTextRenderer,
  List,
  LiveButton,
  LiveButtonInstance,
  Logger,
  MEDIA_KEY_SHORTCUTS,
  MediaControls,
  MediaPlayer,
  MediaPlayerInstance,
  MediaProvider,
  MediaProviderInstance,
  MediaRemoteControl,
  menu as Menu,
  MenuButton,
  MenuButtonInstance,
  MenuInstance,
  MenuItem,
  MenuItemInstance,
  MenuItems,
  MenuItemsInstance,
  MenuPortal,
  MenuPortalInstance,
  MuteButton,
  MuteButtonInstance,
  PIPButton,
  PIPButtonInstance,
  PlayButton,
  PlayButtonInstance,
  PlayerQueryList,
  Poster,
  PosterInstance,
  QualityRadioGroup,
  Radio,
  radioGroup as RadioGroup,
  RadioGroupInstance,
  RadioInstance,
  ScreenOrientationController,
  SeekButton,
  SeekButtonInstance,
  slider as Slider,
  SliderChapters,
  SliderChaptersInstance,
  SliderController,
  SliderInstance,
  SliderPreview,
  SliderPreviewInstance,
  SliderThumbnail,
  SliderThumbnailInstance,
  SliderValue,
  SliderValueInstance,
  SliderVideo,
  SliderVideoInstance,
  SpeedRadioGroup,
  TextRenderers,
  TextTrack,
  TextTrackList,
  thumbnail as Thumbnail,
  ThumbnailInstance,
  ThumbnailsLoader,
  Time,
  TimeInstance,
  TimeRange,
  timeSlider as TimeSlider,
  TimeSliderInstance,
  ToggleButton,
  ToggleButtonInstance,
  tooltip as Tooltip,
  TooltipContent,
  TooltipContentInstance,
  TooltipInstance,
  TooltipTrigger,
  TooltipTriggerInstance,
  Track,
  VideoProviderLoader,
  VideoQualityList,
  volumeSlider as VolumeSlider,
  VolumeSliderInstance,
  appendTriggerEvent,
  canChangeVolume,
  canFullscreen,
  canOrientScreen,
  canPlayHLSNatively,
  canRotateScreen,
  canUsePictureInPicture,
  canUseVideoPresentation,
  createTextTrack,
  defaultLayoutContext,
  findActiveCue,
  findTriggerEvent,
  formatSpokenTime,
  formatTime,
  getDefaultLayoutLang,
  getTimeRangesEnd,
  getTimeRangesStart,
  hasTriggerEvent,
  isAudioProvider,
  isCueActive,
  isHLSProvider,
  isHTMLAudioElement,
  isHTMLMediaElement,
  isHTMLVideoElement,
  isKeyboardClick,
  isKeyboardEvent,
  isPointerEvent,
  isTrackCaptionKind,
  isVideoProvider,
  mediaContext,
  mediaState,
  menuPortalContext,
  observeActiveTextTrack,
  parseJSONCaptionsFile,
  sliderContext,
  sliderState,
  softResetMediaState,
  updateSliderPreviewPlacement,
  useActiveTextCues,
  useActiveTextTrack,
  useActiveThumbnail,
  useAudioOptions,
  useCaptionOptions,
  useChapterOptions,
  useDefaultLayoutContext,
  useMediaPlayer,
  useMediaProvider,
  useMediaRemote,
  useMediaState,
  useMediaStore,
  usePlaybackRateOptions,
  usePlayerQuery,
  useSliderPreview,
  useSliderState,
  useSliderStore,
  useState2 as useState,
  useStore,
  useThumbnails,
  useVideoQualityOptions,
  walkTriggerEventChain
};
//# sourceMappingURL=@vidstack_react.js.map
